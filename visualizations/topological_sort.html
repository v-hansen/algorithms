<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Topological Sort</title>
    <style>
        body { font-family: Arial; max-width: 900px; margin: 50px auto; background: #f5f5f5; }
        canvas { background: white; border: 2px solid #333; display: block; margin: 20px auto; }
        .controls { text-align: center; margin: 20px 0; }
        button { padding: 10px 20px; margin: 5px; font-size: 16px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; }
        .info { text-align: center; margin: 20px; font-size: 16px; }
    </style>
</head>
<body>
    <h1 style="text-align: center;">Topological Sort (DAG)</h1>
    <canvas id="canvas" width="800" height="400"></canvas>
    <div class="controls">
        <button onclick="sort()">Sort</button>
        <button onclick="location.href='index.html'">Back</button>
    </div>
    <div class="info" id="info">Order: []</div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const graph = {0: [1, 2], 1: [3], 2: [3], 3: [4], 4: []};
        const pos = {0: [100, 100], 1: [300, 50], 2: [300, 150], 3: [500, 100], 4: [700, 100]};
        let order = [];

        function draw(visited = [], current = -1) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            for (let node in graph) {
                for (let neighbor of graph[node]) {
                    ctx.strokeStyle = '#999';
                    ctx.beginPath();
                    ctx.moveTo(pos[node][0], pos[node][1]);
                    ctx.lineTo(pos[neighbor][0], pos[neighbor][1]);
                    ctx.stroke();
                    const mx = (pos[node][0] + pos[neighbor][0]) / 2;
                    const my = (pos[node][1] + pos[neighbor][1]) / 2;
                    ctx.beginPath();
                    ctx.moveTo(mx, my);
                    ctx.lineTo(mx - 5, my - 5);
                    ctx.moveTo(mx, my);
                    ctx.lineTo(mx - 5, my + 5);
                    ctx.stroke();
                }
            }
            
            for (let node in pos) {
                ctx.beginPath();
                ctx.arc(pos[node][0], pos[node][1], 25, 0, 2 * Math.PI);
                if (parseInt(node) === current) {
                    ctx.fillStyle = '#ffc107';
                } else if (visited.includes(parseInt(node))) {
                    ctx.fillStyle = '#28a745';
                } else {
                    ctx.fillStyle = '#007bff';
                }
                ctx.fill();
                ctx.stroke();
                ctx.fillStyle = '#fff';
                ctx.font = '18px Arial';
                ctx.fillText(node, pos[node][0] - 5, pos[node][1] + 5);
            }
        }

        async function dfs(node, visited, stack) {
            visited.add(node);
            draw([...visited], node);
            await new Promise(resolve => setTimeout(resolve, 600));
            
            for (let neighbor of graph[node]) {
                if (!visited.has(neighbor)) {
                    await dfs(neighbor, visited, stack);
                }
            }
            stack.push(node);
        }

        async function sort() {
            order = [];
            const visited = new Set();
            const stack = [];
            
            for (let node in graph) {
                if (!visited.has(parseInt(node))) {
                    await dfs(parseInt(node), visited, stack);
                }
            }
            
            order = stack.reverse();
            draw([...visited]);
            document.getElementById('info').textContent = `Order: [${order.join(' â†’ ')}]`;
        }

        draw();
    </script>
</body>
</html>
